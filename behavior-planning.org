#+TITLE: Behavior Planning

* Introduction to Behavior Planning

** The hierarchy of controls in autonomous vehicle

   As the context for behavior planning

| Behavior Planning |            | 10 secs and beyond                                      | take input from prediction and location                                          | output to trajectory                  |
|-------------------+------------+---------------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------|
| Prediction        |            | smaller than behavior planning's                        | input from sensor fusion                                                         | output to trajectory                  |
|-------------------+------------+---------------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------|
| Localization      | Trajectory | smaller than prediction's                               | localization to behavior; trajectory receives input from behavior and prediction | trajectory output to motion control   |
|-------------------+------------+---------------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------|
| Sensor Fusion     |            | larger than motion control's and smaller than the above |                                                                                  | output to prediction and localization |
|-------------------+------------+---------------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------|
| Motion Control    |            | smallest time interval                                  | input from trajectory                                                            |                                       |


Path planning consists of:

- Behavior planning
- Prediction
- Trajectory

** Representation of behavior planning

   - target lane
   - target leading vehicle
   - target speed
   - seconds to reach target (time)

** The problem of behavior planning

   How to reach a destination from a starting position (lane, and spot),
   in terms of lane switch, turn, speed, etc.
   The maneuvers should be
   - feasible,
   - safe
   - legal
   - efficient

   It's not responsible
   - Execution details
   - Collision avoidance

   The above detailed execution should be done in the next level of execution.

** Implementing behavior planning by finite state machine

   - State machine concepts
     - states, finite number of states
       - terminating/accepting state
       - initial state
     - state transition
       - legal transition
       - self transition
     - trigger/event to state transition (input)
     - action performed/side effect during the transition (?)

   - Example of state machine: vending machine
     - all transition cost 20 cents, requiring exact amount

     - only 5 cents (nickel), and 10 cents (dime) money will be used

     - the initial state (start): 0 cents

     - initial state: -- event: enter nickel --> nickel-state
     - initial state: -- event: enter dime --> dime-state
     - etc.

       [[./figures/state-machine-vending.png]]

   - Strength of state machine
     - easy to reason about
       - logical state mapped to physical state
     - easy to maintain/modify, as long as the number of states is small

   - Weakness of state machine
     - Easily abused, too easy to start, with not well thought out state and transition design, accumulating complexity, neglecting the maintainance

     - The number of states could grow to be hard to understand, reason, and maintain.

   - Procedure to design a state machine
     - identify the accepting/terminating state, so that the accepting state would correspond the idea state of the solution sought.
     - Carefully enumerate the states, try to minimize the number of the states

       - prune the states after initial design

       - add additional necessary states

       - consider the various scenarios in the related solution space

         - the states should have sufficient expressiveness to represent the problem/solution space

         - it should be minimal satisfying the objective

         - keep lane vs. change lane

         - consider the analogues, and the opposite, such as speed up vs. slow down, left vs. right, front vs. back, etc. acceleration vs deceleration

     - identify the initial (start) state

     - identify the input/events

     - define the transitions triggered by input/events

   - States for autonomous vehicle on highway:

     - ready/initial state
     - keep lane (keep)

       - keep target speed (removed)

       - speed up (removed)

       - slow down (removed)

       - follow vehicle (removed)

       - stop (removed)

     - prepare for lane change left (removed)
     - prepare for lane change right (removed)
     - change lane left (keep)
     - change lane right (keep)
   - Specification of the states
     - lane keep

       - d state near the center line for lane

       - s drive at the target speed when feasible, otherwise, drive safely in the lane (d near 0 for the lane)

     - prepare lane change left/right (needed, as there are preparation needed before lane change)

       - d stay near center line for current lane (the same as lane keep, but actually for human, one might veer slightly towards the target lane while still within the current lane)

       - s attempt to match position and speed of "gap" in the target (adjacent) lane

       - signal - activate turning signal


     - lane change left/right

       - d move left or right (lane)

       - s same rules as keep lane (for initial lane)

     - The resulted state transition:

     [[./figures/state-transitions-change-lane.png]]


     - The input (events) to autonomous vehicle behavior planning state machine
       - predictions
       - map
       - localization data
       - speed limit
       - current state
     - Model behavior planning as optimal path search
       from the current state, search the optimal (lowest cost) move to the next adjacent state.

       Here is the pseudo code:
       Compute the cost for each possible state, and select the next state with the lowest cost.

       #+NAME:optimal-move
       #+BEGIN_SRC python :noweb yes :tangle :exports code
         def transition_function(predictions, current_fsm_state, current_pose, cost_functions, weights):
             # only consider states which can be reached from current FSM state.
             possible_successor_states = successor_states(current_fsm_state)

             # keep track of the total cost of each state.
             costs = []
             for state in possible_successor_states:
                 # generate a rough idea of what trajectory we would
                 # follow IF we chose this state.
                 trajectory_for_state = generate_trajectory(state, current_pose, predictions)

                 # calculate the "cost" associated with that trajectory.
                 cost_for_state = 0
                 for i in range(len(cost_functions)) :
                     # apply each cost function to the generated trajectory
                     cost_function = cost_functions[i]
                     cost_for_cost_function = cost_function(trajectory_for_state, predictions)

                     # multiply the cost by the associated weight
                     weight = weights[i]
                     cost_for_state += weight * cost_for_cost_function
                  costs.append({'state' : state, 'cost' : cost_for_state})

             # Find the minimum cost state.
             best_next_state = None
             min_cost = 9999999
             for i in range(len(possible_successor_states)):
                 state = possible_successor_states[i]
                 cost  = costs[i]
                 if cost < min_cost:
                     min_cost = cost
                     best_next_state = state

             return best_next_state
       #+END_SRC

     - Use cost function to express preference to the maneuvers, encourage good maneuvers, punish bad maneuvers.

       For example, Speed Limit:
       - Exceeding speed limit, maximum cost

       - Not moving rather high cost
       - in between, vary cost, with zero cost at the ideal speed

         [[ ./figures/speed-cost.png]]

       - Cost model for lane change

         - The cost of lane change should be inverse to the lateral distance traveled for lane change.

         - The cost of lane change should be inverse to the distance to the goal position

         - The cost should be within [0, 1]

         - The following expression satisfies the intuition: $1 - e^{-\frac{|\Delta d|}{\Delta s}}$

       - The challenges of combining multiple constraints (cost) in behavior planning

         - Use additive and weights to combine multiple costs

         - Do regression test to make sure that all the constraints are satisfied and in all situations, typically through simulations

         - Need to have priority in the satisfying the constraints/costs, some are more critical than the others, even magnitude wise, it may be apparent (balancing the costs of drastically different magnitude)

           - Feasibility next
           - Safety first
           - Legality
           - Comfort
           - Then efficiency
         - The importance of the costs may vary in different situations:
           - For example, at the red light, legality is of higher importance than feasibility

           - At merging from ramp to highway, speed should be as close to the other traffic as soon as possible for safety conscern

         - Finer decomposition of cost functions for different aspects (classes) of the constraints:

           - legality: binary

           - safety: binary

           - feasibility: binary

           - comfort: discrete

           - Efficiency: continuous

         - Use optimization techniques to find optimal weights (such as gradient decent), when possible/feasible

         - Consider the vehicle's state, position, velocity, acceleration, etc. as the other dimensions of cost model in addition to the class/aspects of constraints

         - The matrix of considerations
           At the merging into highway, speed to be close to the traffic is important for safety

           [[./figures/consideration-matrix-merge-to-highway.png]]

           At the yellow light, following the traffic law becomes much more important than usual highway driving, which may not be represented enough in the matrix.

           [[./figures/at-yellow-light-considerations-matrix.png]]

           It's getting complex with the state machine, and the inherent complex constraints.

         - Timing requirement of the behavior planner

           Although the behavior planner does not need to be too frequent to provide the planning but it should not block the lower layers' need for behavior planning input.
           It should provide behavior planning output when it's needed, no matter it has the most update data or not. It should provide the best plan with the data available.


** Behavior Planner implementation

*** Implementation in Python

**** Understanding of the existing code

***** The domain model

      There are two main objects:
      - Road
      - Vehicle
****** Road
       Road consists of lanes. Different lanes may have different speeds.
       Road is the stage where vehicles run, or is simulated to run.

       Key attributes:
       - SPEED_LIMIT
       - TRAFFIC_DENSITY ?
       - LANE_SPEEDS: a list of speed for the lanes, with index starting from 0, to num_lanes-1
       - update_width, it may have the value AMOUNT_OF_ROAD_VISIBLE ?
       - density: ?
       - camera_center: ?
       - vehicles: the set of vehicles in the road system, implemented as a map from vehicle_key to vehicle object.
       - vehicles_added: the number of vehicles in the system.

       Road has the behaviors:
       - populate_traffic(), which may add (simulated) vehicles to road's lanes
       - add_ego(initial_pos, vehicle_config), add a vehicle to the road system to be simulated
       - get_ego(): returns the vehicle in focus
       - advance(), the simulation drive of the road system with vehicles in it

       The entry point: advance(), the main routine simulate the road system by repeated calling advance(),
       until the goal position is reached, or time out.

       - Understanding of advance() (dependencies: Vehicle.generate_predictions(), Vehicle.update_state(), Vehicle.realize_state(), Vehicle.increment()
         - by the context where it's used, it must update the simulated position of focused vehicle ego, in order to determine if the simulation can be terminated.
         - It drive all vehicles in the system to generate_predictions to predict over the time horizon the position, and speed of all the vehicles by calling vehicle.state_at()
         - For the ego vehicle, it update_state from the generated predictions, and call ego's realize_state based on the predictions
         - It also call each vehicle's increment to update all the vehicles' speed, and position
         - Question: why it has two loop over the vehicles. The first one only generate the predictions for each vehicle.
           The second one use the generated predictions to update the states of the ego vehicle.
       - Collision
****** Vehicle
       Key attributes:
       - speed_limit
       - initial position on the road in terms of frenet coordinates (s, lane_number)
       - goal: the target spot on the road in terms of frenet coordinates (s, lane_number)
       - max_acceleration
       - lane, the lane the vehicle is in. The lane is index as number from 0, 1, 2, ...
       - s, the s coordinate
       - v, velocity
       - a, acceleration
       - state, default "CS" (constant speed, for the other vehicles assuming they are of constant speed.)
         (The possible states: "KL": keep lane; "LCL" or "LCL": lane change left/right; "PLCL" or "PLCR": prepare lane change left/right.
       - target_speed: the speed limit for the vehicle

       Vehicle has the behaviors:
       - generate_predictions(): drive the simulation of the vehicle's state at each time step in the range of time steps (horizon). It calls Vehicle.state_at(time_step_index).
         update the predictions for the vehicle at all time steps in horizon.
         The returned predictions is a map from vehicle id to list of map: {'s': s, 'lane': lane}.
         The first entry is the position of the vehicle when the prediction starts.
         DEPENDENCY: Vehicle.state_at(time_index)
       - update_state(predictions): given the predictions and the current state, exercise the state machine to determine the next state, and update the state.
         This is the key piece of code needs to implement.
       - realize_state(predictions): simulate the state change with the predictions
       - increment(): increment the s, and v according to the new speed and acceleration.
       - Vehicle.state_at(time_index), predict the state of the vehicle at the time t, based on the model of the vehicle, in terms of the progression of s, and v, assuming no change to lane, and a.
       - dispatching from realize_state:
         - realize_constant_speed: set acceleration to be 0.
         - realize_keep_lane: update the acceleration to be the maximum permitted by the distance in front of the vehicle ego minus the safety buffer. The key to understand is available_room.
           As the simulation is updated in unit time, the acceleration is computed as the distance.
         - realize_lane_change: update the new lane, and adjust the maximum acceleration for the lane changed into.
         - realize_prep_lane_change: based on the vehicle that would be behind the vehicle ego if the vehicle ego would change the lane into, adjust the acceleration to avoid collision.
           (Not fully understood, may need to read further.)
******* Design of update_state

        The intuition of behavior planning. Driving a vehicle is to accelerate in the lane where it is in or hypothetically changes into,
        the maximum that the speed limit and the vehicle in front it allows, and the minimum the car behind it permits not being run into from behind.
        The of the behavior planning is to calculate the relative positions, the speed, the acceleration of the closest car in front, and the back.
        Together with the speed, acceleration, position of the vehicle being planned, the permitted acceleration can be calculated,
        and options of decision can be compared, and the lowest cost can be selected. This intuition is best depicted by a diagram below.


        There is little state machine logic, as from each state, it's possible to transition to every other state, including the current state.
        So the design is to consider all the possible states from the current state, which all the states. Then filtered out the impossible ones according to the current lane.
        When the current lane is 0, the lowest, there is no way to reduce the lane number.
        When the current lane is the maximum, there is no way to increase the lane number.

        (Convention: assuming:
        - right turn reduces lane number;
        - left turn increases lane number;

          This is equivalent to the situation, from the perspective of a driver behind the wheel, the lanes are numbered from right to left (North America).
          )


        Then for each state, considering the total cost from various considerations:
        - Safety
          - collision_cost
          - buffer_cost
        - Comfort
          - change_lane_cost (the discomfort of changing lane)
        - Efficiency: (how fast can the vehicle can reach the goal)
          - distance_from_goal_line (overhead of changing lane)
          - inefficiency_cost

        Then choose the next state that has the lowest cost.
******** Combination of the costs

         Add the costs with weights according to the factors importance to the overall cost (selection decision).
******** Design of individual cost

         For each factor and each proposed state, hypothetically assume the state of the vehicle is in the proposed state, lane, and position,
         then compute the cost in the situation.
 
********* Data collection for cost computation
          For all the cost calculation, there should be predictions of the positions of the other vehicles and
          Ego under the new proposed state in the time step within the horizon.
          The predictions of the other vehicle is obtained in the simulation of the vehicle.advance().
          The hypothetically updated trajectory is calculated based the new proposed state by function vehicle._trajectory_for_state(self, proposed_state, predictions, horizon).
          All the required data is calculated together in get_helper_data.

          Here are the data used in the cost calculations:
              - 'proposed_lane': the (changed) lane with the proposed state
              - 'avg_speed': the average speed with the proposed state and the (changed) lane, the faster the better
              - 'max_acceleration': the acceleration with the maximum of the absolute value, not sure the use of it? Currently, it's not being used.
              - 'rms_acceleration': the average acceleration squared, not sure the use of it? It's not being used.
              - 'closest_approach': the closest distance between Ego and the other vehicles in the same lane, the larger the better, the smaller, the riskier.
              - 'end_distance_to_goal': the distance remaining to the goal, the shorter the better. When it's large, the number of lanes away from the goal lane does not matter.
              - 'end_lanes_from_goal': the number of lanes away from the goal lane, the smaller the better, when the distance to goal line is small.
              - 'collides': record the time step when the first collision happened.

********* Safety

          In the proposed state, evaluate how likely a collision would happen.
          It's accomplished by examining if there is any vehicle shared the same position (the same coordinates, s, and lane).
          This can be computed by predicting the vehicles in the lane in the sufficient time horizon time step. And exam for each time step.
          There it's necessary to have the position data for Ego, and the other vehicles in the same lane.
          This is accomplished in simulation by running the predictions for the horizon for the vehicles in the lane.

          Collision is detected by comparing the s values in the lane with the other vehicles' and Ego's for each time step within the time horizon.
          If there is position duplication (or close to), there is collision.

          Only the buffer in front of Ego is considered.
          It's considered in terms of time to reach the nearest car's position in front of Ego in the same line (data.closest_approach).
          It's there is sufficient time gap, there is no danger, otherwise the danger is inversely related to the value of the time gap.

          It seems to me that we might combine the collision cost and buffer cost together, as they all relate to collision.
          No, but they have different degree of significance. Collision is absolute failure. But lack of buffer is just risk.

********* Comfort
          It's not really considered. It's been used as the same as efficiency.


********* Efficiency
          - distance_from_goal_line: reflect how much cost incurred when change lane. It's proportional to the number of lanes away from the goal lane,
            and inversely proportional the time to the goal. Only when the time to the goal is very close, then changing lane would be severely discouraged.
            I had to increase the magnitude of Efficiency factor to amplify the cost of changing lane to avoid the problem that Ego may be in different lane passing the goal position.

          - inefficiency_cost: reflects if Ego can take advantage of a lane where it can reach Ego's own speed limit as much as possible, if that lane has less car, and allow for higher speed.


***** The top level functions
      #+NAME:simulate_behavior.py
      #+BEGIN_SRC python :noweb yes :tangle ./behavior-planner-python_3/behavior-planner-practice/simulate_behavior.py :exports code
        #!/usr/bin/env python
        from road import Road
        import time

        # impacts default behavior for most states
        SPEED_LIMIT       = 10

        # all traffic in lane (besides ego) follow these speeds
        LANE_SPEEDS       = [6,7,8,9]

        # Number of available "cells" which should have traffic
        TRAFFIC_DENSITY   = 0.15

        # At each timestep, ego can set acceleration to value between
        # -MAX_ACCEL and MAX_ACCEL
        MAX_ACCEL         = 2

        # s value and lane number of goal.
        # GOAL            = (300, 3)
        GOAL              = (300, 0)    # (s, lane)

        # These affect the visualization
        FRAMES_PER_SECOND = 1 # 4
        AMOUNT_OF_ROAD_VISIBLE = 40 # 40

        def main():
          road = Road(SPEED_LIMIT, TRAFFIC_DENSITY, LANE_SPEEDS)
          road.update_width = AMOUNT_OF_ROAD_VISIBLE
          road.populate_traffic()
          ego_config = config = {
            'speed_limit' : SPEED_LIMIT,
            'num_lanes' : len(LANE_SPEEDS),
            'goal' : GOAL,
            'max_acceleration': MAX_ACCEL
          }
          road.add_ego(0, 0, ego_config)  # lane, s, config
          timestep = 0
          while road.get_ego().s <= GOAL[0]:
            timestep += 1
            if timestep > 150:
              print("Taking too long to reach goal. Go faster!")
              break
            road.advance()
            print(road)
            time.sleep(float(1.0) / FRAMES_PER_SECOND)
          ego = road.get_ego()
          if ego.lane == GOAL[1]:
            print("You got to the goal in {} seconds!".format(timestep))
          else:
            print("You missed the goal. You are in lane {} instead of {}.".format(ego.lane, GOAL[1]))

        if __name__ == "__main__":
          main()
     #+END_SRC

***** Road: implementation

      #+NAME:road.py
      #+BEGIN_SRC python :noweb yes :tangle ./behavior-planner-python_3/behavior-planner-practice/road.py :exports code
        import random
        from vehicle import Vehicle
        import pdb

        class Road(object):
          update_width = 70
          ego_rep = " *** "
          ego_key = -1
          def __init__(self, speed_limit, traffic_density, lane_speeds):
            self.num_lanes = len(lane_speeds)
            self.lane_speeds = lane_speeds
            self.speed_limit = speed_limit
            self.density = traffic_density
            self.camera_center = self.update_width / 2
            self.vehicles = {}
            self.vehicles_added = 0
            self.goal_lane = None
            self.goal_s = None

          def get_ego(self):
            return self.vehicles[self.ego_key]

          def populate_traffic(self):
            start_s = max(int(self.camera_center - (self.update_width / 2)), 0)
            for l in range(self.num_lanes):
              lane_speed = self.lane_speeds[l]
              vehicle_just_added = False
              for s in range(start_s, start_s + self.update_width):
                if vehicle_just_added:
                  vehicle_just_added = False
                  continue
                if random.random() < self.density:
                  vehicle = Vehicle(l, s, lane_speed, 0)
                  vehicle.state = "CS"
                  self.vehicles_added += 1
                  self.vehicles[self.vehicles_added] = vehicle
                  vehicle_just_added = True

          def advance(self):
            predictions = {}
            for v_id, v in self.vehicles.items():
              preds = v.generate_predictions()
              predictions[v_id] = preds
            for v_id, v in self.vehicles.items():
              if v_id == self.ego_key:
                v.update_state(predictions)
                v.realize_state(predictions)
              v.increment()

          def add_ego(self, lane_num, s, config_data):
            # pdb.set_trace()
            v_id_to_be_deleted = []
            for v_id, v in self.vehicles.items():
              if v.lane == lane_num and v.s == s:
                v_id_to_be_deleted.append(v_id)
            for v_id in v_id_to_be_deleted:
              del self.vehicles[v_id]  # avoid another vehicle taking place of the vehicle ego.
            ego = Vehicle(lane_num, s, self.lane_speeds[lane_num], 0)
            ego.configure(config_data)
            self.goal_lane = ego.goal_lane
            self.goal_s = ego.goal_s
            ego.state = "KL"
            self.vehicles[self.ego_key] = ego

          def cull(self):
            ego = self.vehicles[self.ego_key]
            center_s = ego.s
            claimed = set([(v.lane, v.s) for v in self.vehicles.values()])
            for v_id, v in self.vehicles.items():
              if v.s > (center_s + self.update_width / 2) or v.s < (center_s - self.update_width / 2):
                try:
                  claimed.remove((v.lane,v.s))
                except:
                  continue
                del self.vehicles[v_id]

                placed = False
                while not placed:
                  lane_num = random.choice(range(self.num_lanes))
                  ds = random.choice(range(self.update_width/2-15,self.update_width/2 -1 ))
                  if lane_num <= self.num_lanes / 2:
                    ds *= -1
                  s = center_s + ds
                  if (lane_num, s) not in claimed:
                    placed = True
                    speed = self.lane_speeds[lane_num]
                    vehicle = Vehicle(lane_num, s, speed, 0)
                    self.vehicles_added += 1
                    self.vehicles[self.vehicles_added] = vehicle
                    print ('adding vehicle {} at lane {} with s={}'.format(self.vehicles_added, lane_num, s))

          def __repr__(self):
            s = self.vehicles.get(self.ego_key).s
            self.camera_center = max(s, self.update_width / 2)
            s_min = max(int(self.camera_center - self.update_width /2), 0)
            s_max = s_min + self.update_width
            road = [["     " if i % 3 == 0 else "     " for ln in range(self.num_lanes)] for i in range(self.update_width)]
            if s_min <= self.goal_s < s_max:
              print("goal_s is {}".format(self.goal_s))
              # pdb.set_trace()
              road[self.goal_s - s_min][self.goal_lane] = " -G- "
            for v_id, v in self.vehicles.items():
              if s_min <= v.s < s_max:
                if v_id == self.ego_key:
                  marker = self.ego_rep
                else:
                  marker = " %03d " % v_id
                try:
                  road[int(v.s) - s_min][v.lane] = marker
                except IndexError:
                  print (v.s, s_min, v.lane)

                  print ("IndexError")
                  pdb.set_trace()
                  continue
            s = ""
            i = s_min
            for l in road:
              if i % 20 == 0:
                s += "%03d - " % i
              else:
                s += "      "
              i += 1
              s += "|" + "|".join(l) + "|"
              s += "\n"
            return s
      #+END_SRC

***** Vehicle: implementation

      #+NAME:vehicle.py
      #+BEGIN_SRC python :noweb yes :tangle  ./behavior-planner-python_3/behavior-planner-practice/vehicle.py :exports code
        from cost_functions import calculate_cost
        from collections import namedtuple
        from copy import deepcopy
        import pdb

        Snapshot = namedtuple("Snapshot", ['lane', 's', 'v', 'a', 'state'])

        class Vehicle(object):
          L = 1                         # the gap between two vehicle, smaller than L consider colliding.
          preferred_buffer = 6 # impacts "keep lane" behavior.

          def __init__(self, lane, s, v, a):
            self.lane = lane
            self.s = s
            self.v = v
            self.a = a
            self.state = "CS"
            self.max_acceleration = None

          def update_state(self, predictions):
            """
            Updates the "state" of the vehicle by assigning one of the
            following values to 'self.state':

            "KL" - Keep Lane
             - The vehicle will attempt to drive its target speed, unless there is
               traffic in front of it, in which case it will slow down.

            "LCL" or "LCR" - Lane Change Left / Right
             - The vehicle will IMMEDIATELY change lanes and then follow longitudinal
               behavior for the "KL" state in the new lane.

            "PLCL" or "PLCR" - Prepare for Lane Change Left / Right
             - The vehicle will find the nearest vehicle in the adjacent lane which is
               BEHIND itself and will adjust speed to try to get behind that vehicle.

            INPUTS
            - predictions
            A dictionary. The keys are ids of other vehicles and the values are arrays
            where each entry corresponds to the vehicle's predicted location at the
            corresponding timestep. The FIRST element in the array gives the vehicle's
            current position. Example (showing a car with id 3 moving at 2 m/s):

            {
              3 : [
                {"s" : 4, "lane": 0},
                {"s" : 6, "lane": 0},
                {"s" : 8, "lane": 0},
                {"s" : 10, "lane": 0},
              ]
            }

            """
            state = self._get_next_state(predictions)
            # pdb.set_trace()
            self.state = state

          def _get_next_state(self, predictions):
            states = ["KL", "LCL", "LCR", "PLCL", "PLCR"]
            if self.lane == 0:          # no more lane reduction, right turn
              states.remove("LCR")
              states.remove("PLCR")
            if self.lane == (self.lanes_available - 1):  # no more lane addition, left turn
              states.remove("LCL")
              states.remove("PLCL")

            costs = []
            for proposed_state in states:
              predictions_copy = deepcopy(predictions)
              trajectory = self._trajectory_for_state(proposed_state, predictions_copy)
              cost = calculate_cost(self, trajectory, predictions)
              costs.append({"state": proposed_state, "cost": cost})

            best = min(costs, key=lambda c: c['cost'])
            return best['state']


          def lane_delta(self, direction):
            """
            Right turn lane number -1;
            Left turn lane number +1
            """
            return -1 if direction == 'R' else 1

          def _trajectory_for_state(self, proposed_state, predictions, horizon=5):
            """
            Based on predictions and the proposed state, produces hypothetically trajectory,
            if the state were changed to the proposed state.
            """
            snapshot = self.snapshot()  # keep a copy of the original vehicle's all data including state

            # imagine to be in the new proposed state
            self.state = proposed_state
            trajectory = [snapshot]
            # pdb.set_trace()
            for i in range(horizon):
              self.restore_state_from_snapshot(snapshot)
              self.state = proposed_state
              self.realize_state(predictions)  # essentially calculate the new lane and the new acceleration
              # in the context of the proposed state, and the predictions, especially the top element in the predictions.
              assert 0 <= self.lane < self.lanes_available, "Wrong lane value after realize_state in _trajectory_for_state: {}. The proposed state: {}.".format(
                self.lane, self.state)
              self.increment()
              trajectory.append(self.snapshot())

              for vehicle_id, position_list in predictions.items():
                position_list.pop()     # remove the used predictions
            # restore state from snapshot
            self.restore_state_from_snapshot(snapshot)
            return trajectory           # predictions changed as side effect, but the input is just a copy, no harm done

          def snapshot(self):
            return Snapshot(self.lane, self.s, self.v, self.a, self.state)

          def restore_state_from_snapshot(self, snapshot):
            self.lane = snapshot.lane
            self.s = snapshot.s
            self.v = snapshot.v
            self.a = snapshot.a
            self.state = snapshot.state

          def configure(self, road_data):
            """
            Called by simulator before simulation begins. Sets various
            parameters which will impact the ego vehicle.
            """
            self.target_speed = road_data['speed_limit']
            self.lanes_available = road_data["num_lanes"]
            self.max_acceleration = road_data['max_acceleration']
            self.goal_s, self.goal_lane = road_data['goal']

          def __repr__(self):
            s = "s:    {}\n".format(self.s)
            s +="lane: {}\n".format(self.lane)
            s +="v:    {}\n".format(self.v)
            s +="a:    {}\n".format(self.a)
            return s

          def increment(self, dt=1):
            """
            update self.s, and self.v in dt time.
            """
            self.s = self.s + self.v * dt + self.a * dt * dt /2
            # here the effect of acceleration is can be ignored, if dt is 1,
            # for one dt, the speed is assumed to be constant.
            self.v = self.v + self.a * dt

          def state_at(self, t):
            """
            Predicts state of vehicle in t seconds (assuming constant acceleration)
            """
            s = self.s + self.v * t + self.a * t * t / 2
            v = self.v + self.a * t
            return self.lane, s, v, self.a

          def collides_with(self, other, at_time=0):
            """
            Simple collision detection.
            """
            l,   s,   v,   a   = self.state_at(at_time)
            l_o, s_o, v_o, a_o = other.state_at(at_time)
            return l == l_o and abs(s-s_o) <= L

          def will_collide_with(self, other, timesteps):
            for t in range(timesteps+1):
              if self.collides_with(other, t):
                return True, t
            return False, None

          def realize_state(self, predictions):
            """
            Given a state, realize it by adjusting acceleration and lane.
            Note - lane changes happen instantaneously.
            """
            state = self.state
            if   state == "CS"  : self.realize_constant_speed()
            elif state == "KL"  : self.realize_keep_lane(predictions)
            elif state == "LCL" : self.realize_lane_change(predictions, "L")
            elif state == "LCR" : self.realize_lane_change(predictions, "R")
            elif state == "PLCL": self.realize_prep_lane_change(predictions, "L")
            elif state == "PLCR": self.realize_prep_lane_change(predictions, "R")

          def realize_constant_speed(self):
            self.a = 0

          def _max_accel_for_lane(self, predictions, lane, s):
            """
            calculate the maximum acceleration permitted given the traffic and the lane.
            """
            delta_v_til_target = self.target_speed - self.v
            max_acc = min(self.max_acceleration, delta_v_til_target)
            in_front = [v for (v_id, v) in predictions.items() if v[0]['lane'] == lane and v[0]['s'] > s ]
            if len(in_front) > 0:
              leading = min(in_front, key=lambda v: v[0]['s'] - s)
              next_pos = leading[1]['s']
              my_next = s + self.v
              separation_next = next_pos - my_next
              available_room = separation_next - self.preferred_buffer
              max_acc = min(max_acc, available_room)
            return max_acc

          def realize_keep_lane(self, predictions):
            self.a = self._max_accel_for_lane(predictions, self.lane, self.s)

          def realize_lane_change(self, predictions, direction):
            self.lane += self.lane_delta(direction)
            assert 0 <= self.lane < self.lanes_available, "Wrong lane value in realize_lane_changetra: {}. The proposed state: {}.".format(
                self.lane, self.state)
            self.a = self._max_accel_for_lane(predictions, self.lane, self.s)

          def realize_prep_lane_change(self, predictions, direction):
            lane = self.lane + self.lane_delta(direction)
            vehicles_behind_same_lane = [vehicle_trajectory for (v_id, vehicle_trajectory) in predictions.items()
                                         if vehicle_trajectory[0]['lane'] == lane and vehicle_trajectory[0]['s'] <= self.s]
            vehicles_front_same_lane = [vehicle_trajectory for (v_id, vehicle_trajectory) in predictions.items()
                                         if vehicle_trajectory[0]['lane'] == lane and self.s <= vehicle_trajectory[0]['s']]
            a_avoiding_smash_behind, delta_s_behind = self.compatible_acceleration(vehicles_front_same_lane, "BEHIND") or (self.a, 0)
            a_avoiding_smash_front, delta_s_front = self.compatible_acceleration(vehicles_front_same_lane, "FRONT") or (self.a, 0)

            if delta_s_behind < delta_s_front:  # only deal with the most urgent risk
              self.a = min(a_avoiding_smash_behind, self.max_acceleration)
            else:
              self.a = max(a_avoiding_smash_front, -self.max_acceleration)

          def compatible_acceleration(self, trajectory, orientation):
            if (0 < len(trajectory)):
              nearest = min(trajectory, key=lambda x: x[0]['s']) if orientation == "FRONT" else max(trajectory, key=lambda x: x[0]['s'])
              other_velocity = nearest[1]['s'] - nearest[0]['s']
              delta_v = (other_velocity - self.v) if orientation == "FRONT" else (self.v - other_velocity)
              if delta_v < 0:           # incompatible velocity, there will be eventually collision
                delta_s = (nearest[0]['s'] - self.s) if orientation == "FRONT" else (self.s - nearest[0]['s'])
                if 0 < delta_s:
                  time = -2 * delta_s / delta_v
                  return -2 * delta_v / time, delta_s
                else:                   # already crashed! Let collision avoidance to take care of it.
                  return None
              else:
                return None  # no worry, can keep the current acceleration
            else:
              return None # no worry, can keep the current acceleration

          def generate_predictions(self, horizon=10):
            predictions = []
            for i in range(horizon):
              lane, s, v, a = self.state_at(i)
              predictions.append({'s':s, 'lane': lane})
            return predictions
      #+END_SRC
***** Cost_functions
      #+NAME:cost_functions
      #+BEGIN_SRC python :noweb yes :tangle ./behavior-planner-python_3/behavior-planner-practice/cost_functions.py :exports code
        from __future__ import division
        from collections import namedtuple
        from math import sqrt, exp
        import pdb

        TrajectoryData = namedtuple("TrajectoryData", [
            'proposed_lane',
            'avg_speed',
            'max_acceleration',
            'rms_acceleration',
            'closest_approach',
            'end_distance_to_goal',
            'end_lanes_from_goal',
            'collides',
        ])

        # priority levels for costs
        COLLISION  = 10 ** 6
        DANGER     = 10 ** 5
        REACH_GOAL = 10 ** 6            # 5 increase to avoid too much changing lane when near the goal
        COMFORT    = 10 ** 4
        EFFICENCY  = 10 ** 2 # 2 EFFICENCY can not be too high to encourage too much lane change.

        DESIRED_BUFFER = 1.5            # time stamps
        PLANNING_HORIZON = 2

        DEBUG = False

        # External interface:
        def calculate_cost(vehicle, trajectory, predictions, verbose=False):
            trajectory_data = get_helper_data(vehicle, trajectory, predictions)
            cost = 0.0
            for cost_function in [
                    distance_from_goal_lane,
                    inefficiency_cost,
                    collision_cost,
                    buffer_cost,
                    change_lane_cost
            ]:
                new_cost = cost_function(vehicle, trajectory, predictions, trajectory_data)
                if DEBUG or verbose:
                    print("{} has cost {} for lane {}".format(cost_function.__name__, new_cost, trajectory[-1].lane))
                    # pdb.set_trace()
                cost += new_cost
            return cost

        # Cost functions:
        def distance_from_goal_lane(vehicle, trajectory, predictions, data):
            """
            cost = REACH_GOAL * (5*data.end_lanes_from_goal/(abs(data.end_distance_to_goal)/data.avg_speed))
            proportional to the number of lanes away from the goal lane;
            inversely proportional to the travel time to the goal
            """
            if data.avg_speed == 0:
                multiplier = 5          # very abnormal situation reject the associated state
            else:
                distance = abs(data.end_distance_to_goal)
                # distance = max(distance, 1.0)
                time_to_goal = float(distance) / data.avg_speed
                lanes = data.end_lanes_from_goal
                multiplier = float(5 * lanes / time_to_goal) if time_to_goal != 0 else 0
            return multiplier * REACH_GOAL

        def inefficiency_cost(vehicle, trajectory, predictions, data):
            """
            Proportional to the difference to the target speed
            """
            cost = ((float(vehicle.target_speed - data.avg_speed)
                     /vehicle.target_speed)**2
            ) * EFFICENCY
            return cost

        def collision_cost(vehicle, trajectory, predictions, data):
            """
            Exponentially inverse to the time when collision happens.
            """
            if data.collides:
                time_til_collision = data.collides['at']
                exponent = (float(time_til_collision))**2
                return exp(-exponent) * COLLISION
            else:
                return 0

        def buffer_cost(vehicle, trajectory, predictions, data):
            """
            The cost of lack of buffer between vehicles.
            When there is sufficient buffer, cost 0.
            Else, the cost is closer to 1 (the maximum), when the buffer is closer to 0.
            """
            if data.closest_approach == 0 or data.avg_speed == 0:
                return 10 * DANGER
            else:
                timesteps_away = data.closest_approach / data.avg_speed
                if DESIRED_BUFFER < timesteps_away:
                    return 0.0
                else:
                    return (1.0 - (timesteps_away - DESIRED_BUFFER)**2) * DANGER

        # def change_lane_cost(vehicle, trajectory, predictions, data):
        #     """
        #     Penalizes lance changes AWAY from the goal lane and rewards lane changes TOWARDS the goal line.
        #     """
        #     cost = 0
        #     proposed_lane = data.end_lanes_from_goal
        #     cur_lanes = trajectory[0].lane
        #     if cur_lanes < proposed_lane:
        #         cost = COMFORT
        #     elif proposed_lane < cur_lanes:
        #         cost = -COMFORT
        #     if cost != 0:
        #         print("!! \n \ncost for lane change is {}\n\n".format(cost))
        #     return cost
        def change_lane_cost(vehicle, trajectory, predictions, data):
            """
            Penalizes lance changes AWAY from the goal lane and rewards lane changes TOWARDS the goal line.
            """
            cost = 0
            time_to_goal = data.end_distance_to_goal/data.avg_speed if data.avg_speed != 0 else 1
            cost = COMFORT* abs(data.end_lanes_from_goal)/time_to_goal if time_to_goal != 0 else COMFORT* abs(data.end_lanes_from_goal)
            return cost

        # Support functions:
        def get_helper_data(vehicle, trajectory, predictions):
            """
            Compute TrajectoryData
            """
            # current_snapshot, first_snapshot, and last_snapshot,
            # are the positions of Ego
            current_snapshot = trajectory[0]
            first_snapshot = trajectory[1]
            last_snapshot = trajectory[-1]
            end_distance_to_goal = vehicle.goal_s - last_snapshot.s
            end_lanes_from_goal = abs(vehicle.goal_lane - last_snapshot.lane)
            delta_time = float(len(trajectory))

            proposed_lane = first_snapshot.lane
            avg_speed = (last_snapshot.s - current_snapshot.s)/delta_time
            # as long as the horizon for trajectory is greater than 1, and acceleration or speed is not 0,
            # the avg_speed should not be 0.
            # assert avg_speed != 0, print("avg_speed should not be zero! {}, lsat_snapshot.s: {}, current_snapshot.s: {}".format(avg_speed, last_snapshot.s, current_snapshot.s, delta_time))
            accels = []
            closest_approach = 999999
            collides = None
            trajectory_same_lane = filter_predictions_by_lane(predictions, proposed_lane)

            for time_step, snapshot in enumerate(trajectory[1:PLANNING_HORIZON+1], 1):  # let the i index start from 1
                lane, s, v, a = unpack_snapshot(snapshot)                       # trajectory is of Ego only
                accels.append(a)        # collects all the accelerations
                for v_id, trajectory_other_vehicle in trajectory_same_lane.items():
                    state = trajectory_other_vehicle[time_step]
                    last_state = trajectory_other_vehicle[time_step-1]
                    vehicle_colides = check_collision(snapshot, last_state['s'], state['s'])
                    if vehicle_colides:
                        collides = collides or {"at": time_step}  # only update collides if it's empty
                    dist = abs(state['s'] - s)
                    if dist < closest_approach:
                        closest_approach = dist
            max_acceleration = max(accels, key=lambda a: abs(a))
            rms_accels = [a**2 for a in accels]
            num_accels = len(rms_accels)
            rms_acceleration = float(sum(rms_accels))/num_accels

            return TrajectoryData(
                proposed_lane,
                avg_speed,
                max_acceleration,
                rms_acceleration,
                closest_approach,
                end_distance_to_goal,
                end_lanes_from_goal,
                collides
            )

        def check_collision(snapshot, s_previous, s_now):
            """
            snapshot: the snapshot of Ego at the time now
            s_previous: the s position of the other vehicle being compared at the last time step.
            s_now: the s position of the other vehicle at the time now
            Check if there is collision with Ego and the other vehicle.
            """
            if s_previous < snapshot.s:
                return snapshot.s <= s_now  # the other vehicle rush from behind
            if snapshot.s < s_previous:
                return s_now <= snapshot.s  # Ego rushs from behind
            if snapshot.s == s_previous:
                return (s_now - s_previous) <= snapshot.v  # the other vehicle moves slower than Ego that Ego may rush from behind and over take.
            raise ValueError

        def filter_predictions_by_lane(predictions, lane):
            filtered = {}
            for v_id, predicted_traj in predictions.items():
                if predicted_traj[0]['lane'] == lane and v_id != -1:
                    filtered[v_id] = predicted_traj
            return filtered

        def unpack_snapshot(snapshot):
            return snapshot.lane, snapshot.s, snapshot.v, snapshot.a
      #+END_SRC

***** Sketch to update_state algorithm
      The following may be outdated.
      #+NAME:state_transition_pseudo
      #+BEGIN_SRC python :noweb yes :tangle :exports none
        if goal_lane == vehicle.lane:
            keep the current lane
        else if the current state is not prepare lane change
        change to prepare to lane change
        else
        lane change
      #+END_SRC
      


***** New problem, sometimes, Ego may not come back to the goal lane in time.
      It seems that the weight for the cost of being away from the goal lane is not enough, when the distance to goal is small.
      Actually, there is not enough cost (penalty) to changing lane when the time to the goal is very small.
      After adding the cost of such changing lane, the problem seems gone.


*** Implementation in C++

    High lever control of the road simulation with ego vehicle.

    #+NAME:main-behavior-planner
    #+BEGIN_SRC C++ :noweb yes :tangle ~/programming/cplusplus/sandbox/src/sandbox.cpp :exports code
      #include "road.h"
      #include "vehicle.h"
      #include <iostream>
      #include <fstream>
      #include <math.h>
      #include <vector>
      #include <unistd.h>

      using namespace std;

      //impacts default behavior for most states
      int SPEED_LIMIT = 10;

      //all traffic in lane (besides ego) follow these speeds
      vector<int> LANE_SPEEDS = {6,7,8,9};

      //Number of available "cells" which should have traffic
      double TRAFFIC_DENSITY   = 0.15;

      // At each timestep, ego can set acceleration to value between
      // -MAX_ACCEL and MAX_ACCEL
      int MAX_ACCEL = 2;

      // s value and lane number of goal.
      vector<int> GOAL = {300, 0}; // s, lane

      // These affect the visualization
      int FRAMES_PER_SECOND = 1; // 4;
      int AMOUNT_OF_ROAD_VISIBLE = 40;

      int main() {
        Road road = Road(SPEED_LIMIT, TRAFFIC_DENSITY, LANE_SPEEDS);
        road.update_width = AMOUNT_OF_ROAD_VISIBLE;
        road.populate_traffic();
        //configuration data: speed limit, num_lanes, goal_s, goal_lane, max_acceleration
        int num_lanes = LANE_SPEEDS.size();
        vector<int> ego_config = {SPEED_LIMIT, num_lanes, GOAL[0], GOAL[1], MAX_ACCEL};

        road.add_ego(3, 0, ego_config); // start lane, start s, ego_config
        int timestep = 0;
        int timestep_limit = 150; // 35 may need to be larger, say 150

        while (road.get_ego().s <= GOAL[0]) {
        // note road.get_ego() returns a copy of the ego at the time of calling, passed by value, so it must be evaluated every while loop.
          timestep++;
          if (timestep_limit < timestep) {
            cout << "Taking too long to reach the goal. Go faster!" << endl;
            break;
          }
          road.advance();
          road.display(timestep);
          // time.sleep(float(1.0) / FRAMES_PER_SECOND);
          sleep(1);
        }
        Vehicle ego = road.get_ego();
        if (ego.lane == GOAL[1]) {
          if (GOAL[0] <= ego.s) cout << "You got to the goal in " << timestep << " seconds!" << endl;
        } else {
          cout << "You missed the goal. You are in lane " << ego.lane << " instead of " << GOAL[1] << "." << endl;
        }
        return 0;
      }
    #+END_SRC

    The declaration of class Vehicle
    #+NAME:vehicle.h
    #+BEGIN_SRC C++ :noweb yes :tangle ~/programming/cplusplus/sandbox/src/vehicle.h :exports code :main no
      #ifndef VEHICLE_H
      #define VEHICLE_H
      #include <iostream>
      #include <random>
      #include <sstream>
      #include <fstream>
      #include <math.h>
      #include <vector>
      #include <map>
      #include <string>
      #include <iterator>

      using namespace std;

      struct TrajectoryData {
        int proposed_lane;
        float avg_speed;
        float max_acceleration;
        float rms_acceleration;
        float closest_approach;
        float end_distance_to_goal;
        int end_lanes_from_goal;
        map<string, int> collides;
      };

      class Vehicle {
      public:
        struct collider{
          bool collision ; // is there a collision?
          int  time; // time collision happens
        };

        int L = 1;                    // what's the meaning of L?
        int preferred_buffer = 6; // impacts "keep lane" behavior.
        int lane;
        int s;
        int v;
        int a;
        int target_speed;
        int lanes_available;
        int max_acceleration;
        int goal_lane;
        int goal_s;
        string state;

        /**
        ,* Constructor
        ,*/
        Vehicle() {};                 // try adding to overcome the error related to slicing of vecotor<Vehicle>
        Vehicle(int lane, int s, int v, int a);
        // Vehicle(const Vehicle & a_vehicle);
        /**
        ,* Destructor
        ,*/
        virtual ~Vehicle();

        void update_state(map<int, vector <vector<int> > > predictions);
        void configure(vector<int> road_data);
        string display();
        void increment(int dt);
        vector<int> state_at(int t);
        bool collides_with(Vehicle other, int at_time);
        collider will_collide_with(Vehicle other, int timesteps);
        void realize_state(map<int, vector < vector<int> > > predictions);
        void realize_constant_speed();
        int _max_accel_for_lane(map<int,vector<vector<int> > > predictions, int lane, int s);
        void realize_keep_lane(map<int, vector< vector<int> > > predictions);
        void realize_lane_change(map<int,vector< vector<int> > > predictions, string direction);
        void realize_prep_lane_change(map<int,vector< vector<int> > > predictions, string direction);
        vector<vector<int> > generate_predictions(int horizon);
        vector<Vehicle> _trajectory_for_state(string proposed_state, map<int, vector < vector<int> > > predictions_copy, int horizon);
        float calculate_cost(vector<Vehicle> trajectory, map<int, vector < vector<int> > > predictions);
        TrajectoryData get_cost_data(vector<Vehicle> trajectory,
                                     map<int, vector < vector<int> > > predictions);
      };
      #endif
    #+END_SRC

    Implementation of Vehicle class.
    to be implemented: udpate_state here, by implementing a state machine, based on the predictions.

    below is the data available for state transition decision:

    target_speed = road_data[0];
    lanes_available = road_data[1];
    goal_s = road_data[2];
    goal_lane = road_data[3];
    max_acceleration = road_data[4];

    #+NAME:vehicle.cpp
    #+BEGIN_SRC C++ :noweb yes :tangle ~/programming/cplusplus/sandbox/src/vehicle.cpp :exports code :main no
      #include <iostream>
      #include <algorithm>
      #include "vehicle.h"
      #include <iostream>
      #include <math.h>
      #include <map>
      #include <string>
      #include <iterator>

      /**
       ,* Initializes Vehicle
       ,*/
      Vehicle::Vehicle(int lane, int s, int v, int a) {
          this->lane = lane;
          this->s = s;
          this->v = v;
          this->a = a;
          state = "CS";
          max_acceleration = -1;
      }

      Vehicle::~Vehicle() {}

      // Vehicle::Vehicle(const Vehicle & a_vehicle) {
      //   this->lane = a_vehicle.lane;
      //   this->s = a_vehicle.s;
      //   this->v = a_vehicle.v;
      //   this->a = a_vehicle.a;
      //   this->state = a_vehicle.state;
      // }

      // TODO - Implement this method.
      void vector_remove(vector<string> & a_vector, string value) {
        a_vector.erase(std::remove(a_vector.begin(), a_vector.end(), value), a_vector.end());
      }

      vector<Vehicle> Vehicle::_trajectory_for_state(string proposed_state,
                                                     map<int, vector < vector<int> > > predictions_copy,
                                                     int horizon=5) {
        // Based on predictions and the proposed state, produces hypothetically trajectory,
        // if the state were changed to the proposed state.

        Vehicle vehicle_hypothetical = Vehicle(*this); // use this to explore hypothetical trajectory,
        // what's the use of this vehicle_hypothetical? It seems that it's been used in the computation.
        // Or it would be the same as the next vehicle_scratch
        vehicle_hypothetical.state = proposed_state;
        vector<Vehicle> trajectory;
        trajectory.push_back(vehicle_hypothetical);
        for (int time_step = 0; time_step < horizon; ++time_step) {
          Vehicle vehicle_scratch = Vehicle(*this);
          vehicle_scratch.state = proposed_state;
          vehicle_scratch.realize_state(predictions_copy);
          vehicle_scratch.increment(1);
          trajectory.push_back(vehicle_scratch);
          for (auto kv:predictions_copy) {
            kv.second.erase(kv.second.begin());
            // This operation is O(n) complexity not constant, n is the number of elements in the vector. May be optimized by replacing vector as dequeue
          }
        }
        return trajectory;         // dumpy for compilation
      }

      template <typename T>
      typename T::iterator min_map_element(T& m) {
        return min_element(m.begin(), m.end(),
                           [](typename T::value_type& l,
                              typename T::value_type& r) -> bool { return l.second < r.second; });
      }

      typedef float (*CostFunction)(Vehicle vehicle, vector<Vehicle> trajectory,
                                    map<int, vector < vector<int> > > predictions,
                                    TrajectoryData);

      map<int, vector < vector<int> > > filter_by_lane(map<int, vector < vector<int> > > predictions,
                                                       int proposed_lane) {
        map<int, vector < vector<int> > > filtered;
        for (auto kv:predictions) {
          if ((kv.first != -1) && (kv.second[0][0] == proposed_lane)) { // lane is at the index 0 of a prediction record
            filtered[kv.first] = kv.second;
          }
        }
        return filtered;
      }

      template <typename T>
      vector<T> slice(const vector<T>& v, int start=0, int end=-1) {
        int oldlen = v.size();
        int newlen;

        if (end == -1 or end >= oldlen){
          newlen = oldlen-start;      // towards the end
        } else {
          newlen = end-start;
        }

        vector<T> nv(newlen);

        for (int i=0; i<newlen; i++) {
          nv[i] = v[start+i];
        }
        return nv;
      }

      // priority levels for costs
      float COLLISION  = pow(10, 6);
      float DANGER     = pow(10, 5);
      float REACH_GOAL = pow(10, 6); // 5 increase to avoid too much changing lane when near the goal
      float COMFORT    = pow(10, 4);
      float EFFICENCY  = pow(10, 2); // 2 EFFICENCY can not be too high to encourage too much lane change.
      float DESIRED_BUFFER = 1.5; // time stamps
      int PLANNING_HORIZON = 2;

      bool check_collision(Vehicle snapshot, float s_previous, float s_now) {
       // snapshot: the snapshot of Ego at the time now
       //    s_previous: the s position of the other vehicle being compared at the last time step.
       //   s_now: the s position of the other vehicle at the time now
       //   Check if there is collision with Ego and the other vehicle.
        if (s_previous < snapshot.s) return (snapshot.s <= s_now); // the other vehicle rush from behind
        if (snapshot.s < s_previous) return (s_now <= snapshot.s); // Ego rushs from behind
        if (snapshot.s == s_previous) return ((s_now - s_previous) <= snapshot.v); // the other vehicle moves slower than Ego that Ego may rush from behind and over take.
        return false;
      }

      TrajectoryData Vehicle::get_cost_data(vector<Vehicle> trajectory,
                                   map<int, vector < vector<int> > > predictions) {
        // Compute the cost data needed to compute the costs
        TrajectoryData cost_data;
        Vehicle current_snapshot       = trajectory[0];
        Vehicle next_snapshot          = trajectory[1];
        Vehicle last_snapshot          = trajectory.back();
        cost_data.end_distance_to_goal = this->goal_s - last_snapshot.s;
        cost_data.end_lanes_from_goal  = abs(this->goal_lane - last_snapshot.lane);
        cost_data.proposed_lane        = next_snapshot.lane;
        cost_data.collides             = {};
        int delta_time = float(trajectory.size());
        cost_data.avg_speed            = (last_snapshot.s - current_snapshot.s)/delta_time;
        cost_data.closest_approach     = 999999;
        map<int, vector < vector<int> > > predictions_same_lane
          = filter_by_lane(predictions, next_snapshot.lane);

        int time_step = 1;            // starts at time_step 1
        vector<Vehicle> trajectory_sliced = slice(trajectory, 1, PLANNING_HORIZON+1);
        for (auto snapshot:trajectory_sliced) {
          for (auto v_id_trajectory:predictions_same_lane) {
            vector<int> state = v_id_trajectory.second[time_step];
            vector<int> last_state = v_id_trajectory.second[time_step-1];
            if (check_collision(snapshot, last_state[1], state[1])) {
              if (cost_data.collides.empty()) cost_data.collides["at"] = time_step;
            }
            float dist = abs(state[1] - snapshot.s);
            if (dist < cost_data.closest_approach) {
              cost_data.closest_approach = dist;
            }
          }
          // ignore cost_data.max_acceleration and cost_data.rms_acceleration, as they are not used.
        }
        return cost_data;
      }

      float _distance_from_goal_lane(Vehicle vehicle, vector<Vehicle> trajectory,
                                     map<int, vector < vector<int> > > predictions,
                                     TrajectoryData data) {
        // cost = REACH_GOAL * (5*data.end_lanes_from_goal/(abs(data.end_distance_to_goal)/data.avg_speed))
        //   proportional to the number of lanes away from the goal lane;
        // inversely proportional to the travel time to the goal
        float multiplier = 0.0;
        if (data.avg_speed == 0) { // very abnormal situation reject the associated state
          multiplier = 5;
        } else {
          float time_to_goal = float(abs(data.end_distance_to_goal)) / data.avg_speed;
          if (time_to_goal != 0) {
            multiplier = float(5 * data.end_lanes_from_goal) / time_to_goal;
          } else {
            multiplier = 0.0;
          }
        }
        return multiplier * REACH_GOAL;
      }

      float _inefficiency_cost(Vehicle vehicle, vector<Vehicle> trajectory,
                               map<int, vector < vector<int> > > predictions,
                               TrajectoryData data) {
        /*
          Proportional to the difference to the target speed
        ,*/
        float cost = (pow(float(vehicle.target_speed - data.avg_speed)
                          /vehicle.target_speed, 2)
                      ) * EFFICENCY;
        return cost;
      }

      float _collision_cost(Vehicle vehicle, vector<Vehicle> trajectory,
                           map<int, vector < vector<int> > > predictions,
                           TrajectoryData data) {
        /*
          Exponentially inverse to the time when collision happens.
        ,*/
        if (!data.collides.empty()) {
          int time_til_collision = data.collides["at"];
          float exponent = pow(float(time_til_collision), 2);
          return exp(-exponent) * COLLISION;
        } else {
          return 0;
        }
      }

      float _buffer_cost(Vehicle vehicle, vector<Vehicle> trajectory,
                        map<int, vector < vector<int> > > predictions,
                        TrajectoryData data) {
        /*
          The cost of lack of buffer between vehicles.
          When there is sufficient buffer, cost 0.
          Else, the cost is closer to 1 (the maximum), when the buffer is closer to 0.
        ,*/
        if ((data.closest_approach == 0) || (data.avg_speed == 0)) {
          return 10 * DANGER;
        } else {
          float timesteps_away = data.closest_approach / data.avg_speed;
          if (DESIRED_BUFFER < timesteps_away) {
            return 0.0;
          } else {
            return (1.0 - pow(timesteps_away - DESIRED_BUFFER, 2)) * DANGER;
          }
        }
      }

      float _change_lane_cost(Vehicle vehicle, vector<Vehicle> trajectory,
                             map<int, vector < vector<int> > > predictions,
                             TrajectoryData data) {
        /*
          Penalizes lance changes AWAY from the goal lane and rewards lane changes TOWARDS the goal line.
        ,*/
        float cost = 0;
        float time_to_goal = 1;
        if (data.avg_speed != 0) {
          time_to_goal = data.end_distance_to_goal/data.avg_speed;
        } else {
          time_to_goal = 1;
        }
        if (time_to_goal != 0) {
          cost = COMFORT* abs(data.end_lanes_from_goal)/time_to_goal;
        } else {
          cost = COMFORT* abs(data.end_lanes_from_goal);
        }
        return cost;
      }

      CostFunction distance_from_goal_lane = & _distance_from_goal_lane;
      CostFunction inefficiency_cost       = & _inefficiency_cost;
      CostFunction collision_cost          = & _collision_cost;
      CostFunction buffer_cost             = & _buffer_cost;
      CostFunction change_lane_cost        = & _change_lane_cost;

      vector<CostFunction> cost_functions = {
        distance_from_goal_lane,
        inefficiency_cost,
        collision_cost,
        buffer_cost,
        change_lane_cost
      };

      float Vehicle::calculate_cost(vector<Vehicle> trajectory,
                                    map<int, vector < vector<int> > > predictions) {
        TrajectoryData cost_data = get_cost_data(trajectory, predictions);
        float cost = 0.0;
        float additional_cost;
        for (auto f:cost_functions) {
          additional_cost = f(*this, trajectory, predictions, cost_data);
          cost += additional_cost;
        }
        return cost;
      }

      void Vehicle::update_state(map<int,vector < vector<int> > > predictions) {
        /*
          Updates the "state" of the vehicle by assigning one of the
          following values to 'self.state':

          "KL" - Keep Lane
           - The vehicle will attempt to drive its target speed, unless there is
             traffic in front of it, in which case it will slow down.

          "LCL" or "LCR" - Lane Change Left / Right
           - The vehicle will IMMEDIATELY change lanes and then follow longitudinal
             behavior for the "KL" state in the new lane.

          "PLCL" or "PLCR" - Prepare for Lane Change Left / Right
           - The vehicle will find the nearest vehicle in the adjacent lane which is
             BEHIND itself and will adjust speed to try to get behind that vehicle.

          INPUTS
          - predictions
          A dictionary. The keys are ids of other vehicles and the values are arrays
          where each entry corresponds to the vehicle's predicted location at the
          corresponding timestep. The FIRST element in the array gives the vehicle's
          current position. Example (showing a car with id 3 moving at 2 m/s):

          {
            3 : [
              {"s" : 4, "lane": 0},
              {"s" : 6, "lane": 0},
              {"s" : 8, "lane": 0},
              {"s" : 10, "lane": 0},
            ]
          }

          ,*/
        vector<string> states = { "KL", "LCL", "LCR", "PLCL", "PLCR" };
        // remove the impossible states
        state = "KL"; // this is an example of how you change state.
        if (this->lane == 0) {        // no more lane reduction, right turn
          vector_remove(states, "LCR");
          vector_remove(states, "PLCR");
        }
        if (this->lane == (this->lanes_available - 1)) { // no more lane addition, left turn
          vector_remove(states, "LCL");
          vector_remove(states, "PLCL");
        }
        map<string, float> costs;     // costs is a map from the state to the corresponding cost
        for (auto proposed_state:states) {
          map<int, vector < vector<int> > > predictions_copy = predictions; // assume this would be deep copy
          vector<Vehicle> trajectory = _trajectory_for_state(proposed_state, predictions_copy, 5);
          float cost = calculate_cost(trajectory, predictions);
          costs[proposed_state] = cost;
        }
        this->state = min_map_element(costs)->first;
      }

      int lane_delta(string direction) {
        /*
                  Right turn lane number -1;
                  Left turn lane number +1
        ,*/
        if (direction == "R")
          return -1;
        else
          return 1;
      }

      void Vehicle::configure(vector<int> road_data) {
        /*
          Called by simulator before simulation begins. Sets various
          parameters which will impact the ego vehicle.
          ,*/
          target_speed = road_data[0];
          lanes_available = road_data[1];
          goal_s = road_data[2];
          goal_lane = road_data[3];
          max_acceleration = road_data[4];
      }

      string Vehicle::display() {

        ostringstream oss;

        oss << "s:    " << this->s << "\n";
          oss << "lane: " << this->lane << "\n";
          oss << "v:    " << this->v << "\n";
          oss << "a:    " << this->a << "\n";

          return oss.str();
      }

      void Vehicle::increment(int dt = 1) {
        this->s += this->v * dt + this->a * dt * dt / 2; // adding + this->a * dt * dt / 2 from state_at
        this->v += this->a * dt;
      }

      vector<int> Vehicle::state_at(int t) {

        /*
          Predicts state of vehicle in t seconds (assuming constant acceleration)
          returns a vector of lane, s, v, a
          ,*/
          int s = this->s + this->v * t + this->a * t * t / 2;
          int v = this->v + this->a * t;
          return {this->lane, s, v, this->a};
      }

      bool Vehicle::collides_with(Vehicle other, int at_time) {

        /*
          Simple collision detection.
          ,*/
          vector<int> check1 = state_at(at_time);
          vector<int> check2 = other.state_at(at_time);
          return (check1[0] == check2[0]) && (abs(check1[1]-check2[1]) <= L);
      }

      Vehicle::collider Vehicle::will_collide_with(Vehicle other, int timesteps) {
        ////////////////////////////////////////////////////////
        // Determine if there will be an eventual collision.  //
        ////////////////////////////////////////////////////////

        Vehicle::collider collider_temp;
        collider_temp.collision = false;
        collider_temp.time = -1;

        for (int t = 0; t < timesteps+1; t++)
        {
              if( collides_with(other, t) )
              {
            collider_temp.collision = true;
            collider_temp.time = t;
                return collider_temp;
            }
        }

        return collider_temp;
      }

      void Vehicle::realize_state(map<int,vector < vector<int> > > predictions) {

        /*
          Given a state, realize it by adjusting acceleration and lane.
          Note - lane changes happen instantaneously.
          ,*/
          string state = this->state;
          if(state.compare("CS") == 0)
          {
            realize_constant_speed();
          }
          else if(state.compare("KL") == 0)
          {
            realize_keep_lane(predictions);
          }
          else if(state.compare("LCL") == 0)
          {
            realize_lane_change(predictions, "L");
          }
          else if(state.compare("LCR") == 0)
          {
            realize_lane_change(predictions, "R");
          }
          else if(state.compare("PLCL") == 0)
          {
            realize_prep_lane_change(predictions, "L");
          }
          else if(state.compare("PLCR") == 0)
          {
            realize_prep_lane_change(predictions, "R");
          }

      }

      void Vehicle::realize_constant_speed() {
        a = 0;
      }

      int Vehicle::_max_accel_for_lane(map<int,vector<vector<int> > > predictions, int lane, int s) {
        /*
          calculate the maximum acceleration permitted given the traffic and the lane.
        ,*/
        int delta_v_til_target = this->target_speed - this->v;
        int max_acc = min(max_acceleration, delta_v_til_target);

        map<int, vector<vector<int> > >::iterator it = predictions.begin();
        vector<vector<vector<int> > > in_front;
        while(it != predictions.end()) {
          // size_t v_id = it->first;
            vector<vector<int> > v = it->second;
            if((v[0][0] == lane) && (v[0][1] > s)) {
                in_front.push_back(v);
              }
              it++;
          }
        if(in_front.size() > 0) {
            int min_s = 1000;
            vector<vector<int>> leading = {};
            for(size_t i = 0; i < in_front.size(); i++)
            {
              if((in_front[i][0][1]-s) < min_s) {
                min_s = (in_front[i][0][1]-s);
                leading = in_front[i];
              }
            }
            int next_pos = leading[1][1];
            int my_next = s + this->v;
            int separation_next = next_pos - my_next;
            int available_room = separation_next - preferred_buffer;
            max_acc = min(max_acc, available_room);
          }
          return max_acc;
      }

      void Vehicle::realize_keep_lane(map<int,vector< vector<int> > > predictions) {
        this->a = _max_accel_for_lane(predictions, this->lane, this->s);
      }

      void Vehicle::realize_lane_change(map<int,vector< vector<int> > > predictions, string direction) {
        this->lane += lane_delta(direction);
        this->a = _max_accel_for_lane(predictions, this->lane, this->s);
      }

      void Vehicle::realize_prep_lane_change(map<int,vector<vector<int> > > predictions, string direction) {
        int lane = this->lane + lane_delta(direction);
        map<int, vector<vector<int> > >::iterator it = predictions.begin();
        vector<vector<vector<int> > > at_behind;
        while(it != predictions.end()) {
            // size_t v_id = it->first;
            vector<vector<int> > v = it->second;
            if((v[0][0] == lane) && (v[0][1] <= this->s)) {
                at_behind.push_back(v);
              }
            it++;
          }
        if(at_behind.size() > 0) {
            int max_s = -1000;
            vector<vector<int> > nearest_behind = {};
            for(size_t i = 0; i < at_behind.size(); i++) {
              if((at_behind[i][0][1]) > max_s) {
                max_s = at_behind[i][0][1];
                nearest_behind = at_behind[i];
              }
            }
            int target_vel = nearest_behind[1][1] - nearest_behind[0][1];
            int delta_v = this->v - target_vel;
            int delta_s = this->s - nearest_behind[0][1];
            if(delta_v != 0) {
              int time = -2 * delta_s/delta_v;
              int a;
              if (time == 0) {
                a = this->a;
              } else {
                a = delta_v/time;
              }
              if(a > this->max_acceleration) {
                a = this->max_acceleration;
              }
              if(a < -this->max_acceleration) {
                a = -this->max_acceleration;
              }
              this->a = a;
            } else {
              int my_min_acc = max(-this->max_acceleration,-delta_s);
              this->a = my_min_acc;
            }
          }
      }

      vector<vector<int> > Vehicle::generate_predictions(int horizon = 10) {
        vector<vector<int> > predictions;
          for( int i = 0; i < horizon; i++) {
            vector<int> check1 = state_at(i); // returns a vector of lane, s, v, a
            vector<int> lane_s = {check1[0], check1[1]}; // extract lane, s
            predictions.push_back(lane_s);
          }
          return predictions;
      }
    #+END_SRC

    #+NAME:road.h
    #+BEGIN_SRC C++ :noweb yes :tangle ~/programming/cplusplus/sandbox/src/road.h :exports code :main no
      #include <iostream>
      #include <random>
      #include <sstream>
      #include <fstream>
      #include <math.h>
      #include <vector>
      #include <set>
      #include <map>
      #include <string>
      #include <iterator>
      #include "vehicle.h"

      using namespace std;

      class Road {
      public:
        int update_width = 70;
        string ego_rep = " *** ";
        int ego_key = -1;
        int num_lanes;
        vector<int> lane_speeds;
        int speed_limit;
        double density;
        int camera_center;
        map<int, Vehicle> vehicles;
        int vehicles_added = 0;

        /**
         ,* Constructor
         ,*/
        Road(int speed_limit, double traffic_density, vector<int> lane_speeds);

        /**
         ,* Destructor
         ,*/
        virtual ~Road();

        Vehicle get_ego();
        void populate_traffic();
        void advance();
        void display(int timestep);
        void add_ego(int lane_num, int s, vector<int> config_data);
        void cull();
      };
    #+END_SRC

    #+NAME:road.cpp
    #+BEGIN_SRC C++ :noweb yes :tangle ~/programming/cplusplus/sandbox/src/road.cpp :exports code :main no
      #include <iostream>
      #include "road.h"
      #include "vehicle.h"
      #include <iostream>
      #include <math.h>
      #include <map>
      #include <string>
      #include <iterator>

      /**
       ,* Initializes Road
       ,*/
      Road::Road(int speed_limit, double traffic_density, vector<int> lane_speeds) {
          this->num_lanes = lane_speeds.size();
          this->lane_speeds = lane_speeds;
          this->speed_limit = speed_limit;
          this->density = traffic_density;
          this->camera_center = this->update_width/2;
      }

      Road::~Road() {}

      Vehicle Road::get_ego() {
        return this->vehicles.find(this->ego_key)->second;
      }

      void Road::populate_traffic() {
        int start_s = max(this->camera_center - (this->update_width/2), 0);
        for (int l = 0; l < this->num_lanes; l++) {
          int lane_speed = this->lane_speeds[l];
          bool vehicle_just_added = false;
          for(int s = start_s; s < start_s+this->update_width; s++) {
            if(vehicle_just_added) {
              vehicle_just_added = false;
            }
            if(((double) rand() / (RAND_MAX)) < this->density) {
              Vehicle vehicle = Vehicle(l,s,lane_speed,0);
              vehicle.state = "CS";
              this->vehicles_added += 1;
              this->vehicles.insert(std::pair<int,Vehicle>(vehicles_added,vehicle));
              vehicle_just_added = true;
            }
          }
        }
      }

      void Road::advance() {
        map<int ,vector<vector<int> > > predictions;
        map<int, Vehicle>::iterator it = this->vehicles.begin();
        while(it != this->vehicles.end()) {
              int v_id = it->first;
              vector<vector<int> > preds = it->second.generate_predictions(10);
              predictions[v_id] = preds;
              it++;
          }
        it = this->vehicles.begin();
        while(it != this->vehicles.end()) {
            int v_id = it->first;
              if(v_id == ego_key) {
                it->second.update_state(predictions);
                it->second.realize_state(predictions);
              }
              it->second.increment(1);
              it++;
          }
      }

      void Road::display(int timestep) {
        Vehicle ego = this->vehicles.find(this->ego_key)->second;
        int s = ego.s;
        string state = ego.state;

        this->camera_center = max(s, this->update_width/2);
        int s_min = max(this->camera_center - this->update_width/2, 0);
        int s_max = s_min + this->update_width;

        vector<vector<string> > road;

        for(int i = 0; i < this->update_width; i++) {
            vector<string> road_lane;
            for(int ln = 0; ln < this->num_lanes; ln++) {
              road_lane.push_back("     ");
            }
            road.push_back(road_lane);
        }

        map<int, Vehicle>::iterator it = this->vehicles.begin();
        while(it != this->vehicles.end()) {
          int v_id = it->first;
          Vehicle v = it->second;

          if(s_min <= v.s && v.s < s_max) {
            string marker = "";
            if(v_id == this->ego_key) {
              marker = this->ego_rep;
            } else {
              stringstream oss;
              stringstream buffer;
              buffer << " ";
              oss << v_id;
              for(int buffer_i = oss.str().length(); buffer_i < 3; buffer_i++) {
                buffer << "0";
              }
              buffer << oss.str() << " ";
              marker = buffer.str();
            }
            road[int(v.s - s_min)][int(v.lane)] = marker;
          }
          it++;
        }
        ostringstream oss;
        oss << "+Meters ======================+ step: " << timestep << endl;
        int i = s_min;
        for(size_t lj = 0; lj < road.size(); lj++) {
          if(i%20 ==0) {
            stringstream buffer;
            stringstream dis;
            dis << i;
            for(int buffer_i = dis.str().length(); buffer_i < 3; buffer_i++) {
              buffer << "0";
            }
            oss << buffer.str() << dis.str() << " - ";
          } else {
            oss << "      ";
          }
          i++;
          for(size_t li = 0; li < road[0].size(); li++) {
            oss << "|" << road[lj][li];
          }
          oss << "|";
          oss << "\n";
        }
        cout << oss.str();
      }

      void Road::add_ego(int lane_num, int s, vector<int> config_data) {
        vector<int> to_removed_v_id;
        map<int, Vehicle>::iterator it = this->vehicles.begin();
        while(it != this->vehicles.end()) {
          int v_id = it->first;
          Vehicle v = it->second;
          if(v.lane == lane_num && v.s == s) {
            // this->vehicles.erase(v_id);
            to_removed_v_id.push_back(v_id);
          }
          it++;
        }
        // safer remove keys
        for (auto v_id:to_removed_v_id) {
          this->vehicles.erase(v_id);
        }

        Vehicle ego = Vehicle(lane_num, s, this->lane_speeds[lane_num], 0);
        ego.configure(config_data);
        ego.state = "KL";
        this->vehicles.insert(std::pair<int,Vehicle>(ego_key,ego));
      }

      void Road::cull() {
        Vehicle ego = this->vehicles.find(this->ego_key)->second;
        int center_s = ego.s;
        set<vector<int>> claimed;

        map<int, Vehicle>::iterator it = this->vehicles.begin();
        while(it != this->vehicles.end()) {
          // size_t v_id = it->first;
          Vehicle v = it->second;
          vector<int> claim_pair = {v.lane,v.s};
          claimed.insert(claim_pair);
          it++;
        }
        it = this->vehicles.begin();
        while(it != this->vehicles.end()) {
          int v_id = it->first;
          Vehicle v = it->second;
          if( (v.s > (center_s + this->update_width / 2) ) || (v.s < (center_s - this->update_width / 2) ) ) {
            try {
              claimed.erase({v.lane,v.s});
            }
            catch (const exception& e) {
              continue;
            }
            this->vehicles.erase(v_id);

            bool placed = false;
            while(!placed) {
              int lane_num = rand() % this->num_lanes;
              int ds = rand() % 14 + (this->update_width/2-15);
              if(lane_num > this->num_lanes/2) {
                ds*=-1;
              }
              int s = center_s + ds;
              if(claimed.find({lane_num,s}) != claimed.end()) {
                placed = true;
                int speed = lane_speeds[lane_num];
                Vehicle vehicle = Vehicle(lane_num, s, speed, 0);
                this->vehicles_added++;
                this->vehicles.insert(std::pair<int,Vehicle>(vehicles_added,vehicle));
                cout << "adding vehicle "<< this->vehicles_added << " at lane " << lane_num << " with s=" << s << endl;
              }
            }
          }
          it++;
        }
      }
    #+END_SRC
